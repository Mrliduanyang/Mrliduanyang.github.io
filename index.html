<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;mrliduanyang.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta property="og:type" content="website">
<meta property="og:title" content="N.O的个人技术备忘">
<meta property="og:url" content="https://mrliduanyang.github.io/index.html">
<meta property="og:site_name" content="N.O的个人技术备忘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mrliduanyang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mrliduanyang.github.io/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>N.O的个人技术备忘</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">N.O的个人技术备忘</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mrliduanyang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Mrliduanyang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Mrliduanyang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:duanyangchn@gmail.com" title="E-Mail → mailto:duanyangchn@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/11/02/%E5%AD%97%E5%85%B8%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/11/02/%E5%AD%97%E5%85%B8%E6%A0%91/" class="post-title-link" itemprop="url">LeetCode分享（字典树）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-11-02 20:36:34 / 修改时间：20:38:51" itemprop="dateCreated datePublished" datetime="2021-11-02T20:36:34+08:00">2021-11-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>字典树设计的核心思想是空间换时间，所以数据结构本身比较消耗空间。但它利用了字符串的共同前缀（Common Prefix）作为存储依据，以此来节省存储空间，并减少搜索时间。字典树常被应用于快速检索（最长前缀匹配）、统计、排序和保存大量的字符串，所以经常被搜索引擎系统用于文本词频统计、搜索提示等场景。</p>
<p>今天分享两道字典树相关的题目。分别是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">LeetCode 208. 实现 Trie (前缀树)</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">LeetCode 211. 添加与搜索单词 - 数据结构设计</a></li>
</ul>
<h2 id="字典树实战"><a href="#字典树实战" class="headerlink" title="字典树实战"></a>字典树实战</h2><h3 id="LeetCode-208-实现-Trie-前缀树"><a href="#LeetCode-208-实现-Trie-前缀树" class="headerlink" title="LeetCode 208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">LeetCode 208. 实现 Trie (前缀树)</a></h3><blockquote>
<p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code>向前缀树中插入字符串<code>word</code> 。</li>
<li><code>boolean search(String word)</code>如果字符串<code>word</code>在前缀树中，返回<code>true</code>（即，在检索之前已经插入）；否则，返回<code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code>如果之前已经插入的字符串<code>word</code>的前缀之一为<code>prefix</code> ，返回<code>true</code>；否则，返回<code>false</code>。</li>
</ul>
<p><strong>输入：</strong></p>
<p>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]</p>
<p>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]</p>
<p><strong>输出：</strong></p>
<p>[null, null, true, false, true, null, true]</p>
</blockquote>
<p>先来分析字典树的数据结构。从题目可知，字典树是一种树形数据结构，那接下来的就要确定树中节点的数据结构了。假定有如下所示的一棵字典树，我们想一下字典树是如何实现前缀查找的：</p>
<p><img src="https://raw.githubusercontent.com/Mrliduanyang/ImageHosting/main/image-20211101181437949.png" alt="image-20211101181437949"></p>
<ol>
<li>从根节点开始查找；</li>
<li>在 root 节点上获取查找字符串的第一个字符，根据该字符选择对应的子节点，转到该字节点继续查找；</li>
<li>在子节点上获取查找字符串的第二个字符，进一步转到对应的子节点进行查找；</li>
<li>重复执行步骤 3，不断地在字典树中查找；</li>
<li>直到查找字符串中所有字符都被取出或者当前节点的子节点不存在对应字符时，查找完成。</li>
</ol>
<p>假定字典树中只存储 a-z，共 26 个小写英文字母，则可以暂定字典树中节点的数据结构为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    val char</span><br><span class="line">    children [<span class="number">26</span>]*Trie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样设计的节点数据结构是有数据冗余的，其中的<code>val</code>字段是多余的。回顾字典树查找过程，在每一步获取查找字符串的字符后，都是转入子节点继续查找，完全没有当前节点<code>val</code>字段的信息，可以去除该字段。</p>
<p>接下来分析如何构造字典树。再次回顾字典树查找过程，查找的一个结束条件是当前节点的子节点不存在对应字符，修改该条件，如果子节点不存在对应字符，则创建该字符对应的节点，并转入该节点继续构造。据此，可以写出字典树构造过程的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    children [<span class="number">26</span>]*Trie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    node := t</span><br><span class="line">    <span class="comment">// 迭代获取word中的字符ch</span></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="comment">// 如果node的children中没有ch对应的节点，创建对应的节点</span></span><br><span class="line">        <span class="keyword">if</span> node.children[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            node.children[ch] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转入ch对应的节点</span></span><br><span class="line">        node = node.children[ch]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之相对的字典树查找过程的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    node := t</span><br><span class="line">    <span class="comment">// 迭代获取word的字符ch</span></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="comment">// 如果node的children中没有ch对应的节点，查找失败</span></span><br><span class="line">        <span class="keyword">if</span> node.children[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转入ch对应的节点</span></span><br><span class="line">        node = node.children[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// word中的每个字符都能被查找到，查找成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去挺完美的，但还有一些特殊情况没有处理。在字典树中插入一个字符串后，对该字符串的所有前缀执行查找操作，都会返回<code>true</code>，但这是不正确的。为解决这个问题，需要在字典树节点中添加额外的标识信息。将字典树节点的数据结构修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    children [<span class="number">26</span>]*Trie</span><br><span class="line">    <span class="comment">// 该节点是否是终止节点</span></span><br><span class="line">    isEnd <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在插入和查找中增加对<code>isEnd</code>的处理即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了返回值类型，便于判断isEnd</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">SearchPrefix</span><span class="params">(word <span class="keyword">string</span>)</span> *<span class="title">Trie</span></span> &#123;</span><br><span class="line">    node := t</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.children[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 返回nil，而不是false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回node，而不是true</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    node := t.SearchPrefix(word)</span><br><span class="line">    <span class="comment">// 既要存在于字典树中，又要有结束标识</span></span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nil</span> &amp;&amp; node.isEnd</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前缀查找</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.SearchPrefix(prefix) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来分析一下字典树的复杂度，很多人可能会觉得，字典树也是一棵树，所以各种操作的时间复杂度肯定会带有$\log$，但其实不是。回顾字典树的插入和查找操作，决定复杂度的关键是对<code>word</code>的遍历操作。所以其插入和查找的时间复杂度均为$O(word_length)$。这一点和树的操作有些不同，因为对树的插入和查找操作，要从根节点开始，平均进行树高（$\log n$）次比较，才能定位到节点位置，然后再进行操作。而在字典树中，字符串中字符的插入和查找只跟它的上一个字符有关，因此，操作复杂度取决于字符串的长度。还要注意一点，在树中插入和查找的是节点，而在字典树中插入和查找的是一个字符串。</p>
<h3 id="LeetCode-211-添加与搜索单词-数据结构设计"><a href="#LeetCode-211-添加与搜索单词-数据结构设计" class="headerlink" title="LeetCode 211. 添加与搜索单词 - 数据结构设计"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">LeetCode 211. 添加与搜索单词 - 数据结构设计</a></h3><blockquote>
<p>请你设计一个数据结构，支持添加新单词和查找字符串是否与任何先前添加的字符串匹配。</p>
<p>实现词典类 <code>WordDictionary</code> ：</p>
<ul>
<li><code>WordDictionary()</code>初始化词典对象</li>
<li><code>void addWord(word)</code> 将<code>word</code>添加到数据结构中，之后可以对它进行匹配</li>
<li><code>bool search(word)</code> 如果数据结构中存在字符串与<code>word</code>匹配，则返回<code>true</code>；否则，返回<code>false</code>。<code>word</code>中可能包含一些<code>&#39;.&#39;</code>，每个<code>&#39;.&#39;</code>都可以表示任何一个字母。</li>
</ul>
<p><strong>输入：</strong></p>
<p>[“WordDictionary”,”addWord”,”addWord”,”addWord”,”search”,”search”,”search”,”search”]</p>
<p>[[],[“bad”],[“dad”],[“mad”],[“pad”],[“bad”],[“.ad”],[“b..”]]</p>
<p><strong>输出：</strong></p>
<p>[null,null,null,null,false,true,true,true]</p>
</blockquote>
<p>来分析题目，还是要实现添加字符串和查找单字符串的功能，添加字符串还是字典树的常规插入操作，但在查找字符串时有些不一样。题目要求，字符串中可能存在<code>&#39;.&#39;</code>，可以用来表示任何一个字母。<strong>对这种情况的处理也简单，直接在搜索到<code>.</code>时，直接转向所有子节点进行查找即可。</strong></p>
<p>参考字典树的模板代码，可写出该题的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TrieNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TrieNode)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在TrieNode基础上封装成WordDictionary</span></span><br><span class="line"><span class="keyword">type</span> WordDictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    trieRoot *TrieNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">WordDictionary</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> WordDictionary&#123;&amp;TrieNode&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span> <span class="title">AddWord</span><span class="params">(word <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 调用TrieNode的Insert方法</span></span><br><span class="line">    this.trieRoot.Insert(word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *WordDictionary)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 递归形式。也可改成基于栈的非递归形式，本质是n叉树的深度优先遍历</span></span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, *TrieNode)</span> <span class="title">bool</span></span></span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>, node *TrieNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="comment">// 一种递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(word) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.isEnd</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch := word[idx]</span><br><span class="line">        <span class="comment">// 处理非.号的情况</span></span><br><span class="line">        <span class="keyword">if</span> ch != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">            child := node.children[ch-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">            <span class="comment">// 直接进入ch对应子节点</span></span><br><span class="line">            <span class="keyword">if</span> child != <span class="literal">nil</span> &amp;&amp; helper(idx+<span class="number">1</span>, child) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="keyword">range</span> node.children &#123;</span><br><span class="line">                child := node.children[i]</span><br><span class="line">                <span class="comment">// 递归进入当前节点的所有子节点进行判断</span></span><br><span class="line">                <span class="keyword">if</span> child != <span class="literal">nil</span> &amp;&amp; helper(idx+<span class="number">1</span>, child) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他的递归结束情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">0</span>, this.trieRoot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/06/10/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/10/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%982/" class="post-title-link" itemprop="url">有趣的前端面试题II</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-06-10 18:33:09 / 修改时间：18:36:00" itemprop="dateCreated datePublished" datetime="2021-06-10T18:33:09+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>还是腾讯的暑期实习生面试题，由于是电话面，面试官口述题目，题目大概是这样的：“有一个对象，对象中有一个方法，方法中又有一个局部函数。问局部函数中的this指向谁？”。翻译成代码就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fn2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又是让人懵逼的一题。到底在考察什么？函数作用域？<code>this</code>指向？在解决这个问题之前，我们先来回顾一下<code>JavaScript</code>中<code>this</code>的表现，具体可参阅<a href="%E5%8F%82%E9%98%85%E6%96%87%E6%A1%A3"><code>MDN</code>文档</a>。</p>
<h2 id="1-this示例"><a href="#1-this示例" class="headerlink" title="1. this示例"></a>1. <code>this</code>示例</h2><h3 id="1-1-函数上下文中的this"><a href="#1-1-函数上下文中的this" class="headerlink" title="1.1 函数上下文中的this"></a>1.1 函数上下文中的<code>this</code></h3><p><code>this</code>的值取决于函数被调用的方式，可通过<code>call</code>、<code>apply</code>改变函数执行时的<code>this</code>。</p>
<h3 id="1-2-bind方法"><a href="#1-2-bind方法" class="headerlink" title="1.2 bind方法"></a>1.2 <code>bind</code>方法</h3><p>调用<code>fn.bind(someObject)</code>会创建一个与<code>fn</code>具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code>将永久地被绑定到了<code>bind</code>的第一个参数，无论这个函数是如何被调用的。</p>
<h3 id="1-3-箭头函数"><a href="#1-3-箭头函数" class="headerlink" title="1.3 箭头函数"></a>1.3 箭头函数</h3><p>在箭头函数中，<code>this</code>与封闭词法环境的<code>this</code>保持一致。在全局代码中，它将被设置为全局对象。无论如何，箭头函数的 <code>this</code> 被设置为它被创建时的环境。这同样适用于在其他函数内创建的箭头函数：这些箭头函数的<code>this</code>被设置为封闭的词法环境的<code>this</code>。</p>
<h3 id="1-4-作为对象的方法"><a href="#1-4-作为对象的方法" class="headerlink" title="1.4 作为对象的方法"></a>1.4 作为对象的方法</h3><p>当函数作为对象里的方法被调用时，<code>this</code> 被设置为调用该函数的对象。这样的行为完全不会受函数定义方式或位置的影响。<code>this</code> 的绑定只受最接近的成员引用的影响。</p>
<h3 id="1-5-原型链中的this"><a href="#1-5-原型链中的this" class="headerlink" title="1.5 原型链中的this"></a>1.5 原型链中的<code>this</code></h3><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 <code>this</code> 指向的是调用这个方法的对象，就像该方法就在这个对象上一样。</p>
<h3 id="1-6-getter与setter中的this"><a href="#1-6-getter与setter中的this" class="headerlink" title="1.6 getter与setter中的this"></a>1.6 getter与setter中的<code>this</code></h3><p>再次，相同的概念也适用于当函数在一个 <code>getter</code> 或者 <code>setter</code> 中被调用。用作 <code>getter</code> 或 <code>setter</code> 的函数都会把 <code>this</code> 绑定到设置或获取属性的对象。</p>
<h3 id="1-7-作为构造函数"><a href="#1-7-作为构造函数" class="headerlink" title="1.7 作为构造函数"></a>1.7 作为构造函数</h3><p>当一个函数用作构造函数时（使用<code>new</code>关键字），它的<code>this</code>被绑定到正在构造的新对象。</p>
<h3 id="1-8-作为一个DOM事件处理函数"><a href="#1-8-作为一个DOM事件处理函数" class="headerlink" title="1.8 作为一个DOM事件处理函数"></a>1.8 作为一个DOM事件处理函数</h3><p>当函数被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素。</p>
<h3 id="1-9-作为一个内联事件处理函数"><a href="#1-9-作为一个内联事件处理函数" class="headerlink" title="1.9 作为一个内联事件处理函数"></a>1.9 作为一个内联事件处理函数</h3><p>当代码被内联<code>on-event</code>处理函数调用时，它的<code>this</code>指向监听器所在的DOM元素。</p>
<h3 id="1-10-类中的this"><a href="#1-10-类中的this" class="headerlink" title="1.10 类中的this"></a>1.10 类中的<code>this</code></h3><p>和其他普通函数一样，方法中的 <code>this</code> 值取决于它们如何被调用。</p>
<h2 id="2-尝试解决"><a href="#2-尝试解决" class="headerlink" title="2. 尝试解决"></a>2. 尝试解决</h2><p>回头看面试题中的例子，<code>fn2</code>中的<code>this</code>和上述示例中的1.1还是比较像的，<code>this</code>的值取决于函数被调用的方式，但具体是谁呢？很多人就会想了，调用嵌套函数时<code>this</code>会指向调用外层函数的上下文，在这里也就是<code>fn</code>的上下文，但这么理解是不对的。和变量不同，关键字<code>this</code>没有作用域的限制，嵌套的函数不会从调用它的函数中继承<code>this</code>。在<strong>《JavaScript权威指南》</strong>中，有明确给出这个问题的答案：“如果嵌套函数作为方法调用，其<code>this</code>的值指向调用它的对象。如果嵌套函数作为函数调用，其<code>this</code>值不是全局对象（非严格模式下）就是<code>undefined</code>（严格模式下）”。</p>
<p>再来看<code>MDN</code>文档中关于<code>this</code>示例1.1的描述，给了这么一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量，并将该变量作为全局对象 window 的属性。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a; <span class="comment">// this的值取决于函数被调用的方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatsThis(); <span class="comment">// &#x27;Global&#x27;，因为在这个函数中this没有被设定，所以它默认为全局/window对象</span></span><br></pre></td></tr></table></figure>

<p><code>whatsThis</code>作为函数调用，没有设定<code>this</code>，所以它默认为<code>全局/window对象</code>。<code>fn2</code>中的<code>this</code>可参考此例。</p>
<p>如果想访问这个外部函数的<code>this</code>，需要将<code>this</code>的值保存在一个变量里，这个变量和内部函数都在同一个作用域内。通常使用变量<code>self</code>来保存<code>this</code>，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj); <span class="comment">// true，this就是这个对象obj</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj); <span class="comment">// false，this的值是全局对象或undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self === obj); <span class="comment">// true，self指外部函数的this值</span></span><br><span class="line">        &#125;</span><br><span class="line">        fn2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/05/27/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/27/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">有趣的前端面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-27 12:37:37 / 修改时间：12:41:09" itemprop="dateCreated datePublished" datetime="2021-05-27T12:37:37+08:00">2021-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近在参加腾讯暑期实习生面试的时候，被问了一个题，题目是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">a.toString();</span><br></pre></td></tr></table></figure>

<p>面试官问的是“变量<code>a</code>为什么能调用<code>toString()</code>方法？”。</p>
<p>反正我当时是想了想，然后回答的是：“在调用时，会沿着<code>a</code>的原型链查找，直到找到<code>toString()</code>方法。”，然后面试官说：“<code>a</code>是原始值，也不是个对象，怎么找它的原型链呢？”然后我就懵了。</p>
<p>下来之后，想深入研究一下这个问题，但却发现，甚至都没法在搜索引擎中输入这个对问题的描述。但好在在《JavaScript高级程序设计》里找到了答案。</p>
<p>书上是这么说的：</p>
<blockquote>
<p>为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：<code>Boolean</code>、<code>Number</code>和<code>String</code>。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>在这里，<code>s1</code>是一个包含字符串的变量，它是一个原始值。第二行紧接着在<code>s1</code>上调用了<code>substring()</code>方法，并把结果保存在<code>s2</code>中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。具体来说，当第二行访问<code>s1</code>时，是以读模式访问的，也就是从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3步：</p>
<ol>
<li>创建一个<code>String</code>类型的实例；</li>
<li>调用实例上的特定方法；</li>
<li>销毁实例。</li>
</ol>
<p>可以把这3步想象成执行了如下3行ECMAScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也会在后台发生，只不过使用的是<code>Boolean</code>和<code>Number</code>包装类型而已。</p>
</blockquote>
<p>了解完以上内容，就可以解决最开始的面试题了。当以读模式访问变量<code>a</code>时，会先创建与<code>a</code>对应的<code>Number</code>包装类型的实例，然后调用该实例上的<code>toString()</code>方法。</p>
<p>但这是不是意味着可以像操作对象一样任意地给原始类型变量添加删除属性呢？不是的。接着来看书上的内容：</p>
<blockquote>
<p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过<code>new</code>实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">consolel.log(s1.color);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>这里的第二行代码尝试给字符串<code>s1</code>添加一个<code>color</code>属性。可是，第三行代码访问<code>color</code>属性时它却不见了。原因就是第二行代码运行时会临时创建一个<code>String</code>对象，而当第三行代码执行时，这个对象已经被销毁了。实际上，第三行代码在这里创建了自己的<code>String</code>对象，但这个对象没有<code>color</code>属性。</p>
</blockquote>
<p>可以显式地使用<code>Boolean</code>、<code>Number</code>和<code>String</code>构造函数创建原始值包装对象。不过应该在确实必要时再这么做，否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用<code>typeof</code>会返回<code>object</code>，所有原始值包装对象都会转换为布尔值<code>true</code>。虽然不推荐显式创建原始值包装类型的实例，但它们对于操作原始值的功能是很重要的。每个原始值包装类型都有相应的一套方法来方便数据操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/05/11/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/11/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">排序专题（时间复杂度O(n^2)级排序算法）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-05-11 13:11:52 / 修改时间：14:10:49" itemprop="dateCreated datePublished" datetime="2021-05-11T13:11:52+08:00">2021-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文整理自LeetBook《排序算法全解析》，原书地址：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/detail/sort-algorithms/%E3%80%82%E6%9C%AC%E6%96%87%E5%9C%A8%E5%8E%9F%E6%96%87%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%95%A5%E5%8A%A0%E4%BF%AE%E6%94%B9%E3%80%82">https://leetcode-cn.com/leetbook/detail/sort-algorithms/。本文在原文基础上略加修改。</a></p>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h2><p>冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法：</p>
<ul>
<li>一边比较一边向后两两交换，将最大值/最小值冒泡到最后一位；</li>
<li>经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；</li>
<li>进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。</li>
</ul>
<h3 id="1-1-第一种写法"><a href="#1-1-第一种写法" class="headerlink" title="1.1 第一种写法"></a>1.1 第一种写法</h3><p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.Length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; nums.Length - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                Swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最外层的循环每经过一轮，剩余数字中的最大值就会被移动到当前轮次的最后一位，中途也会有一些相邻的数字经过交换变得有序。</p>
<p>这种写法相当于相邻的数字两两比较，并且规定：“谁大谁站右边”，每经过一轮，确定一个数字的位置。整个过程看起来就像一个个气泡不断上浮，这也是“冒泡排序”名字的由来。</p>
<h3 id="1-2-第二种写法"><a href="#1-2-第二种写法" class="headerlink" title="1.2 第二种写法"></a>1.2 第二种写法</h3><p>第二种写法是在第一种写法的基础上改良而来的：</p>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> swapped = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.Length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; nums.Length - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                Swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最外层的循环每经过一轮，剩余数字中的最大值仍然是被移动到当前轮次的最后一位。</p>
<p>这种写法相对于第一种写法的优点是：<strong>如果一轮比较中没有发生过交换，则立即停止排序，因为此时剩余数字一定已经有序了</strong>。</p>
<h3 id="1-3-第三种写法"><a href="#1-3-第三种写法" class="headerlink" title="1.3 第三种写法"></a>1.3 第三种写法</h3><p>第三种写法比较少见，它是在第二种写法的基础上进一步优化：</p>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> swapped = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> indexOfLastUnsortedElement = nums.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> swappedIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapped) &#123;</span><br><span class="line">        swapped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; indexOfLastUnsortedElement; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                Swap(nums, i, i + <span class="number">1</span>);</span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">                swappedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indexOfLastUnsortedElement = swappedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过再一次的优化，代码看起来就稍微有点复杂了。最外层的循环每经过一轮，剩余数字中的最大值仍然是被移动到当前轮次的最后一位。</p>
<p>在下一轮比较时，只需比较到上一轮最后一次发生交换的位置即可。因为后面的所有元素都没有发生过交换，必然已经有序了。</p>
<p>当一轮比较中从头到尾都没有发生过交换，则表示整个列表已经有序，排序完成。</p>
<h3 id="1-4-交换的技巧"><a href="#1-4-交换的技巧" class="headerlink" title="1.4 交换的技巧"></a>1.4 交换的技巧</h3><p>（1）一般来说，交换两个数字a，b的方法如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br></pre></td></tr></table></figure>

<p>（2）不引入第三个中间变量完成两个数字的交换：</p>
<p>这里可以用到一个数学上的技巧</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = a + b;</span><br><span class="line">a = b - a;</span><br><span class="line">b = b - a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了这种先加后减的写法，还有一种先减后加的写法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br><span class="line">b = b + a;</span><br></pre></td></tr></table></figure>

<p>但这两种方式都可能导致数字越界。</p>
<p>（3）通过位运算完成数字交换：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>

<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2 选择排序"></a>2 选择排序</h2><p>选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。</p>
<h3 id="2-1-第一种写法"><a href="#2-1-第一种写法" class="headerlink" title="2.1 第一种写法"></a>2.1 第一种写法</h3><p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectionSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.Length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> minIdx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; nums.Length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[minIdx] &gt; nums[j]) &#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Swap(nums, i, minIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-第二种写法"><a href="#2-2-第二种写法" class="headerlink" title="2.2 第二种写法"></a>2.2 第二种写法</h3><p>选择排序算法也是可以优化的，即在每轮遍历时同时找出最小值和最大值。这就是二元选择排序的思想。</p>
<p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectionSort2</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.Length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> minIdx = i;</span><br><span class="line">        <span class="keyword">var</span> maxIdx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; nums.Length - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[minIdx] &gt; nums[j]) minIdx = j;</span><br><span class="line">            <span class="keyword">if</span> (nums[maxIdx] &lt; nums[j]) maxIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minIdx == maxIdx) <span class="keyword">break</span>;</span><br><span class="line">        Swap(nums, i, minIdx);</span><br><span class="line">		<span class="comment">// 这里的判断，处理了一种特殊情况。如果nums[i]和nums[maxIdx]相等，因为上一行中nums[i]和nums[minIdx]交换了位置，所以此时nums[maxIdx]（也就是nums[i]）其实已经被交换到nums[minIdx]的位置上了，需要更新maxIdx。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIdx == i) maxIdx = minIdx;</span><br><span class="line">        <span class="keyword">var</span> lastIdx = nums.Length - <span class="number">1</span> - i;</span><br><span class="line">        Swap(nums, lastIdx, maxIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3 插入排序"></a>3 插入排序</h2><p>插入排序的思想非常简单，在有序数组中找到待插入数字的正确位置，将其插入，逐渐完成整个排序。</p>
<p>插入排序有两种写法：</p>
<ul>
<li>交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。</li>
<li>移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。</li>
</ul>
<h3 id="3-1-第一种写法"><a href="#3-1-第一种写法" class="headerlink" title="3.1 第一种写法"></a>3.1 第一种写法</h3><p>代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nums.Length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">1</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            Swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当只有一个数字时，不存在排序问题，所以直接从第二个数字开始往前插入。维护好有序部分，新加入的数字先安排在最后一个位置，然后它不断地与前面的数字比较，如果前面的数字比它大，它就和前面的数字交换位置。</p>
<h3 id="3-2-第二种写法"><a href="#3-2-第二种写法" class="headerlink" title="3.2 第二种写法"></a>3.2 第二种写法</h3><p>在交换法插入排序中，每次交换数字时都会进行三次赋值操作。但新插入的这个数字并不一定会被放在正确位置。可能它刚换到新的位置上不久，下一次比较后可能马上又会被换到前一个数字的位置。</p>
<p> 一种优化方案是让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。</p>
<p>这种方案我们需要把新插入的数字暂存起来，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nums.Length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> curNum = nums[i];</span><br><span class="line">        <span class="keyword">var</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; curNum &lt; nums[j]) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[j + <span class="number">1</span>] = curNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>维护好有序部分，当有新的数字要加入，有序部分不断地向后腾出位置，当新的数字找到自己合适的位置后，就可以直接插入。重复此过程，直到排序结束。</p>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本文介绍了三种基础排序算法：冒泡排序、选择排序、插入排序。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序有两种优化方式：</p>
<ul>
<li>记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序；</li>
<li>记录上次发生交换的位置，下一轮排序时只比较到此位置。</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序可以演变为二元选择排序：</p>
<ul>
<li>二元选择排序：一次遍历选出两个值——最大值和最小值；</li>
<li>二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序有两种写法：</p>
<ul>
<li>交换法：新数字通过不断交换找到自己合适的位置；</li>
<li>移动法：旧数字不断向后移动，直到新数字找到合适的位置。</li>
</ul>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>时间复杂度都是$O(n^2)$空间复杂度都是$O(1)$。</li>
<li>都需要采用两重循环。</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>选择排序是不稳定的，冒泡排序、插入排序是稳定的；</li>
<li>在这三个排序算法中，选择排序交换的次数是最少的；</li>
<li>在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/04/20/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/20/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="post-title-link" itemprop="url">LeetCode分享（最近公共祖先）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-20 01:37:50" itemprop="dateCreated datePublished" datetime="2021-04-20T01:37:50+08:00">2021-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-02 20:38:40" itemprop="dateModified" datetime="2021-11-02T20:38:40+08:00">2021-11-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本次带大家盘点LeetCode上的“最近公共祖先”相关的问题，一共有5道，分别是</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">LeetCode 235. 二叉搜索树的最近公共祖先</a>；</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236. 二叉树的最近公共祖先</a>；</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/">LeetCode 1644. 二叉树的最近公共祖先 II</a>；</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/">LeetCode 1650. 二叉树的最近公共祖先 III</a>；</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/">LeetCode 1676. 二叉树的最近公共祖先 IV</a>。</li>
</ul>
<p>我们不按照题号顺序来讲解，而是按照相近性来组织。</p>
<h2 id="0-LeetCode-235"><a href="#0-LeetCode-235" class="headerlink" title="0. LeetCode 235"></a>0. LeetCode 235</h2><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大<strong>（一个节点也可以是它自己的祖先）</strong>。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210411160028.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br><strong>输出：</strong> 6<br><strong>解释：</strong> 节点 2 和节点 8 的最近公共祖先是 6。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br><strong>输出：</strong> 2<br><strong>解释：</strong> 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
</blockquote>
<h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>这题给定的是一个二叉搜索树，其他几个题都是二叉树，所以我们可以利用二叉搜索树的性质来确定搜索方向。同时还要留意，p、q节点一定存在于给定的二叉搜索树中，这就简化了我们的判断，因为不需要考虑查询节点不在树中的情况，闭着眼往深了搜就行。</p>
<ul>
<li>从根节点开始遍历；</li>
<li>如果当前节点的值大于p和q的值，说明p和q应该在当前节点的左子树，因此递归进入左孩子节点；</li>
<li>如果当前节点的值小于p和q的值，说明p和q应该在当前节点的右子树，因此递归进入右孩子节点；</li>
<li>如果当前节点的值不满足上述两条要求，那么又会有两种情况，这两种情况都可以直接返回当前节点：<ul>
<li>p和q分别在当前节点的不同子树中；</li>
<li>当前节点就是p或q。</li>
</ul>
</li>
</ul>
<p>上述思路很容易用递归形式实现，所以我们定义递归函数的功能是：<strong>返回p、q节点的最近公共祖先</strong>。算法代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">LowestCommonAncestor</span>(<span class="params">TreeNode root, TreeNode p, TreeNode q</span>)</span> &#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Helper</span>(<span class="params">TreeNode node, TreeNode p, TreeNode q</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; node.val &amp;&amp; q.val &lt; node.val)</span><br><span class="line">            <span class="keyword">return</span> Helper(node.left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (p.val &gt; node.val &amp;&amp; q.val &gt; node.val)</span><br><span class="line">            <span class="keyword">return</span> Helper(node.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Helper(root, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对照算法，参考上图的二叉搜索树，我们来模拟几个查询：</p>
<ol>
<li>p=2，q=8：从node=6开始，发现p和q分别在node两侧，返回node=6即可。</li>
<li>p=0，q=4：从node=6开始，发现p和q都比node小，于是递归进入node的左子树；node=2，发现p和q分别在node两侧，逐级返回node=2即可。</li>
<li>p=4，q=3：从node=6开始，发现p和q都比node小，于是递归进入node的左子树；node=2，发现p和q都比node大，于是递归进入node的右子树；node=4，发现node=p，逐级返回node=4即可。</li>
</ol>
<p>我们还要留意一点，最近公共祖先需要满足深度尽可能大，那我们的算法满足这点吗？肯定是满足的，因为整个算法第一次找到正确答案的位置就是一个尽可能深的位置（再往深处是不可能存在答案的），算法在返回答案的时候，也是按照递归调用顺序逐级返回该答案，因而可以保证最近公共祖先的正确性。</p>
<h2 id="LeetCode-236"><a href="#LeetCode-236" class="headerlink" title="LeetCode 236"></a>LeetCode 236</h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p> <strong>示例 1：</strong></p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210411183622.png" alt="img"></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br><strong>输出：</strong> 3<br><strong>解释：</strong> 节点 5 和节点 1 的最近公共祖先是节点 3 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br><strong>输出：</strong> 5<br><strong>解释：</strong> 节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> root = [1,2], p = 1, q = 2<br><strong>输出：</strong> 1</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 [2, 105] 内。</li>
<li>-109 &lt;= Node.val &lt;= 109</li>
<li>所有 Node.val 互不相同 。</li>
<li>p != q</li>
<li>p 和 q 均存在于给定的二叉树中。</li>
</ul>
</blockquote>
<h3 id="思路与算法-1"><a href="#思路与算法-1" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>有了上一题的基础，再看这一题就简单了很多。</p>
<p>首先还是要读题，和上一题不同的是，这一题给的树是二叉树，不满足二叉搜索的性质，但相同的是，p和q都在树中。</p>
<p>不满足二叉搜索性质，还能用上一题的思路吗？能的。回顾上一题，我们利用二叉搜索的性质做了什么？我们只是根据待查询节点和根节点的大小关系，确定搜索方向而已。那假如不能确定向左子树搜索还是向右子树搜索怎么办呢？也很简单，不确定向哪边搜索，那就都搜索，肯定能保证不会漏掉节点。</p>
<p>按照上一题的大体思路，将单侧递归改为两侧递归，算法代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">LowestCommonAncestor</span>(<span class="params">TreeNode root, TreeNode p, TreeNode q</span>)</span> &#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Helper</span>(<span class="params">TreeNode node, TreeNode p, TreeNode q</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件，如果在不存在p、q的分支搜索，只能递归到底然后返回null；如果在存在p、q的分支搜索，搜索到p或q返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || node == p || node == q) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">// 向左侧递归搜索</span></span><br><span class="line">        <span class="keyword">var</span> left = Helper(node.left, p, q);</span><br><span class="line">        <span class="comment">// 向右侧递归搜索</span></span><br><span class="line">        <span class="keyword">var</span> right = Helper(node.right, p, q);</span><br><span class="line">        <span class="comment">// 处理搜索结果，如果分别在左右两侧找到p或q，返回node即可</span></span><br><span class="line">        <span class="comment">// 分析上述结论，首先从题中可知p、q在树中唯一且不等，p、q相对于node的位置只有四种</span></span><br><span class="line">        <span class="comment">// （1）p、q都在node左侧</span></span><br><span class="line">        <span class="comment">// （2）p、q都在node右侧</span></span><br><span class="line">        <span class="comment">// （3）p都在node左侧，q在node右侧</span></span><br><span class="line">        <span class="comment">// （4）q都在node左侧，p在node右侧</span></span><br><span class="line">        <span class="comment">// 我们不可能画出一棵有两个节点左右两侧都有p和q的树，所以可以确定当p、q分居node两侧时，node即为最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">// 当p、q只在node一侧出现，另一侧的返回结果肯定为null，返回非null的结果即可</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="literal">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Helper(root, p, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-1676"><a href="#LeetCode-1676" class="headerlink" title="LeetCode 1676"></a>LeetCode 1676</h2><blockquote>
<p>给定一棵二叉树的根节点 root 和 TreeNode 类对象的数组（列表） nodes，返回 nodes 中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都存在于该二叉树中，且二叉树中所有节点的值都是互不相同的。</p>
<p>我们扩展二叉树的最近公共祖先节点在维基百科上的定义：“对于任意合理的 i 值， n 个节点 p1 、 p2、…、 pn 在二叉树 T 中的最近公共祖先节点是后代中包含所有节点 pi 的最深节点（我们允许一个节点是其自身的后代）”。一个节点 x 的后代节点是节点 x 到某一叶节点间的路径中的节点 y。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210411184006.png" alt="img"></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [4,7]<br><strong>输出：</strong> 2<br><strong>解释：</strong> 节点 4 和 7 的最近公共祖先是 2。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [1]<br><strong>输出：</strong> 1<br><strong>解释：</strong> 单个节点的最近公共祖先是该节点本身。</p>
<p><strong>示例 3：</strong> </p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [7,6,2,4]<br><strong>输出：</strong> 5<br><strong>解释：</strong> 节点 7、6、2 和 4 的最近公共祖先节点是 5。</p>
<p><strong>示例 4：</strong></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], nodes = [0,1,2,3,4,5,6,7,8]<br><strong>输出：</strong> 3<br><strong>解释：</strong> 树中所有节点的最近公共祖先是根节点。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点个数的范围是 [1, 104] 。</li>
<li>-109 &lt;= Node.val &lt;= 109</li>
<li>所有的 Node.val 都是互不相同的。</li>
<li>所有的 nodes[i] 都存在于该树中。</li>
<li>所有的 nodes[i] 都是互不相同的。</li>
</ul>
</blockquote>
<h3 id="思路与算法-2"><a href="#思路与算法-2" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>这道题相对于上题而言，只是把p、q两节点的条件改为了节点列表nodes，但本质上来讲，两道题没有区别。我们来想一下上一题的递归结束条件<strong>如果在不存在p、q的分支搜索，只能递归到底然后返回null；如果在存在p、q的分支搜索，搜索到p或q返回即可</strong>，那在这题里面，我们搜索到nodes中任意一个返回就可以了。</p>
<p>为什么可以这么想呢？我们站在p、q关系的角度来看上一题。在符合题目要求的二叉树中，p、q的相对位置关系只有两种（1）”祖先-孙子”关系，如：<strong>p=3、q=5，p=5、q=2，p=5、q=7</strong>；（2）非”祖先-孙子”关系，如：<strong>p=5、q=1，p=5、q=0，p=7、q=1</strong>。这两种关系也恰好对应了算法中对<strong>left</strong>和<strong>right</strong>结果的处理。把这种关系推广到本题，多个节点之间也是满足这种关系的。如果多个节点分成两组后分在节点node的两侧，则node就是所有节点的最近公共祖先；如果多个节点都在节点node的一侧，则多个节点中距离node最近的那个就是他们的最近公共祖先。改写上题的算法代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">LowestCommonAncestor</span>(<span class="params">TreeNode root, TreeNode[] nodes</span>)</span> &#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Helper</span>(<span class="params">TreeNode node</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 重点，递归结束条件改为判断nodes中是否包含node</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || nodes.Contains(node)) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">var</span> l = Helper(node.left);</span><br><span class="line">        <span class="keyword">var</span> r = Helper(node.right);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> l == <span class="literal">null</span> ? r : l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Helper(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode-1644"><a href="#LeetCode-1644" class="headerlink" title="LeetCode 1644"></a>LeetCode 1644</h2><blockquote>
<p>给定一棵二叉树的根节点 root，返回给定节点 p 和 q 的最近公共祖先（LCA）节点。<strong>如果 p 或 q 之一不存在于该二叉树中，返回 null。</strong>树中的每个节点值都是互不相同的。</p>
<p>根据维基百科中对最近公共祖先节点的定义：“两个节点 p 和 q 在二叉树 T 中的最近公共祖先节点是后代节点中既包括 p 又包括 q 的最深节点（我们允许一个节点为自身的一个后代节点）”。一个节点 x 的后代节点是节点 x 到某一叶节点间的路径中的节点 y。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210411183713.png" alt="img"></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br><strong>输出：</strong> 3<br><strong>解释：</strong> 节点 5 和 1 的共同祖先节点是 3。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br><strong>输出：</strong> 5<br><strong>解释：</strong> 节点 5 和 4 的共同祖先节点是 5。根据共同祖先节点的定义，一个节点可以是自身的后代节点。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10<br><strong>输出：</strong> null<br><strong>解释：</strong> 节点 10 不存在于树中，所以返回 null。</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点个数的范围是 [1, 104]。</li>
<li>-109 &lt;= Node.val &lt;= 109</li>
<li>所有节点的值 Node.val 是互不相同的。</li>
<li>p != q</li>
</ul>
</blockquote>
<h3 id="算法与思路"><a href="#算法与思路" class="headerlink" title="算法与思路"></a>算法与思路</h3><p>粗略一看，感觉和上一题没什么区别。但要留意一点，<strong>本题中的p、q节点不一定存在于给定的二叉树中</strong>。这就导致我们上面题目中的思路都不能用。为什么呢？因为在上面三道题目中，都明确指明p、q节点都在二叉树中，所以我们的递归函数可以定义为：<strong>返回p、q节点的最近公共祖先</strong>。这样定义的话，如果递归返回的是null，则能确定p或q不在当前子树。但如果把该递归函数应用到本题，如果递归返回null，我们无法确定是因为p或q不在子树中返回的null还是p或q根本就不在给定树中导致的搜索失败返回null。</p>
<p>我们需要调整思路，将递归函数调整为：<strong>判断p、q节点是否在当前子树中</strong>。这样做相对于直接返回最近公共祖先的好处在于，如果p或q不在当前子树中，那我们还可以再额外判断p或q是否等于当前根节点。这样等到递归结束时，我们是可以判定p或q是否真的存在于二叉树中。</p>
<p>按上述思路，改写算法代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">LowestCommonAncestor</span>(<span class="params">TreeNode root, TreeNode p, TreeNode q</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 因为递归函数不再直接返回最近公共祖先的结果，需要使用一个全局变量来保存最近公共祖先</span></span><br><span class="line">    TreeNode ans = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 递归函数定义：判断p或q节点是否在当前树中</span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">Helper</span>(<span class="params">TreeNode node, TreeNode p, TreeNode q</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归结束条件，搜索到null时，只能返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">var</span> left = Helper(node.left, p, q);</span><br><span class="line">        <span class="keyword">var</span> right = Helper(node.right, p, q);</span><br><span class="line">        <span class="comment">// 更新结果，只在两种情况下才会更新：</span></span><br><span class="line">        <span class="comment">// （1）left和right都为true，说明p、q都存在且分在node两侧，ans更新为node</span></span><br><span class="line">        <span class="comment">// （2）p或q等于node并且node的左子树或右子树中存在p或q</span></span><br><span class="line">        <span class="keyword">if</span> ((left &amp;&amp; right) || ((node.val == p.val || node.val == q.val) &amp;&amp; (left || right))) &#123;</span><br><span class="line">            ans = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归函数返回值，如果当前节点左子树或者右子树中存在p或q，或者当前节点就是p或q，都可以返回true</span></span><br><span class="line">        <span class="keyword">return</span> left || right || (node.val == p.val || node.val == q.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Helper(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode-1650"><a href="#LeetCode-1650" class="headerlink" title="LeetCode 1650"></a>LeetCode 1650</h2><blockquote>
<p>给定一棵二叉树中的两个节点 p 和 q，返回它们的最近公共祖先节点（LCA）。</p>
<p>每个节点都包含其父节点的引用（指针）。Node 的定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="keyword">public</span> Node parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>根据维基百科中对最近公共祖先节点的定义：“两个节点 p 和 q 在二叉树 T 中的最近公共祖先节点是后代节点中既包括 p 又包括 q 的最深节点（我们允许一个节点为自身的一个后代节点）”。一个节点 x 的后代节点是节点 x 到某一叶节点间的路径中的节点 y。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210411183921.png" alt="img"></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br><strong>输出：</strong> 3<br><strong>解释：</strong> 节点 5 和 1 的最近公共祖先是 3。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br><strong>输出：</strong> 5<br><strong>解释：</strong> 节点 5 和 4 的最近公共祖先是 5，根据定义，一个节点可以是自身的最近公共祖先。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong> root = [1,2], p = 1, q = 2<br><strong>输出：</strong> 1</p>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点个数的范围是 [2, 105]。</li>
<li>-109 &lt;= Node.val &lt;= 109</li>
<li>所有的 Node.val 都是互不相同的。</li>
<li>p != q</li>
<li>p 和 q 存在于树中。</li>
</ul>
</blockquote>
<h3 id="算法与思路-1"><a href="#算法与思路-1" class="headerlink" title="算法与思路"></a>算法与思路</h3><p>这道题和上面四题又都不一样。这题其实是<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">LeetCode 160. 相交链表</a>的变形，思路也是使用相交链表的思路。为什么说是相交链表的变形呢？因为当我们从p、q节点出发向父节点走，一直走到根节点，忽略掉其他所有没有访问到的节点，我们就得到了两个不同的链表，然后这两个链表在p、q最近公共祖先的位置相交了。</p>
<p>算法思想很简单，跟着走两遍就能体会原理了。更详细的算法讲解可以参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">LeetCode 160. 相交链表</a>的相关题解。代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">LowestCommonAncestor</span>(<span class="params">Node p, Node q</span>)</span> &#123;</span><br><span class="line">    Node a = p, b = q;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        <span class="comment">// a从p开始向上走，走到根节点后，回到q继续</span></span><br><span class="line">        a = (a.parent == <span class="literal">null</span>) ? q : a.parent;</span><br><span class="line">        <span class="comment">// b从q开始向上走，走到根节点后，回到p继续</span></span><br><span class="line">        b = (b.parent == <span class="literal">null</span>) ? p : b.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/04/03/%E5%8F%8C%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/03/%E5%8F%8C%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">LeetCode分享（双递归）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-03 12:17:47" itemprop="dateCreated datePublished" datetime="2021-04-03T12:17:47+08:00">2021-04-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-11 13:09:11" itemprop="dateModified" datetime="2021-05-11T13:09:11+08:00">2021-05-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天做到一道挺有意思的递归题目，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">LeetCode 863. 二叉树中所有距离为 K 的结点</a>。看到这题，感觉似曾相识啊，深度、广度优先搜索都能找到距离K吧。但细看题目后，发现问题不是那么简单，它不是从根出发的距离K，而是距离某个给定节点target的距离K。</p>
<h2 id="0-题目描述"><a href="#0-题目描述" class="headerlink" title="0. 题目描述"></a>0. 题目描述</h2><blockquote>
<p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。</p>
<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。</p>
<p>示例 1：</p>
<p><strong>输入：</strong> root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2<br><strong>输出：</strong> [7,4,1]<br><strong>解释：</strong><br>所求结点为与目标结点（值为 5）距离为 2 的结点，<br>值分别为 7，4，以及 1</p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210402101328.png" alt="img"></p>
<p>注意，输入的 “root” 和 “target” 实际上是树上的结点。<br>上面的输入仅仅是对这些对象进行了序列化描述。</p>
</blockquote>
<h2 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1.思路分析"></a>1.思路分析</h2><p>一个很容易想到的思路是计算各节点和目标节点之间的距离。以图上的树为例，要找到和节点5距离为2的节点，只可能顺着节点5找它的孩子节点，看有没有距离为2的；或者从节点5往上走一步，走到节点3，发现节点3有右子树，就可以找有没有和节点3距离为1（节点5到节点3消耗了1个距离）的节点。</p>
<p>用递归可以很容易实现，我们定义递归函数的功能是<strong>返回传入node节点到target节点的距离</strong>。如果想知道从node到target的距离，就得先设法知道从node的左右孩子出发到target的距离，所以这大体上是一个<strong>“递归后序遍历”</strong>，我们抽象出算法的架子。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Helper</span>(<span class="params">TreeNode node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (node == target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获得左右孩子到target的距离</span></span><br><span class="line">    <span class="built_in">int</span> leftDis = Helper(node.left), rightDis = Helper(node.right);</span><br><span class="line">    <span class="comment">// 获得node到target的距离</span></span><br><span class="line">    <span class="keyword">if</span> (leftDis != <span class="number">-1</span> || rightDis != <span class="number">-1</span>) <span class="keyword">return</span> (leftDis <span class="keyword">or</span> rightDis) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// target不等于node，leftDis和rightDis又都是-1，说明target就不在node的树上，距离也为-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Helper(root);</span><br></pre></td></tr></table></figure>

<p>我们在上面算法框架的基础上加亿点点细节，标记<strong>TODO</strong>的地方是需要具体实现的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">DistanceK</span>(<span class="params">TreeNode root, TreeNode target, <span class="built_in">int</span> K</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">Helper</span>(<span class="params">TreeNode node</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 走到null，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == target) &#123;</span><br><span class="line">            <span class="comment">// TODO 如果node是target，把到node距离为K的节点添加进res</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> leftDis = Helper(node.left), rightDis = Helper(node.right);</span><br><span class="line">        <span class="comment">// 实际上，两个if分支只会走一个，因为target不可能既出现在node左子树，又出现在右子树</span></span><br><span class="line">        <span class="keyword">if</span> (leftDis != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftDis == K) </span><br><span class="line">                <span class="comment">// TODO 如果沿node左子树走到target的距离是K，把node添加进res</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (leftDis &lt; K) </span><br><span class="line">                <span class="comment">// TODO 如果沿node左子树走到target的距离小于K</span></span><br><span class="line">                <span class="comment">// 说明到target距离为K的节点在node的右子树上</span></span><br><span class="line">                <span class="comment">// 把node的右子树中到node的距离加上leftDis等于K的节点添加进res</span></span><br><span class="line">            <span class="comment">// 如果leftDis大于K，什么也不做</span></span><br><span class="line">            <span class="keyword">return</span> leftDis + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightDis != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightDis == K)</span><br><span class="line">                <span class="comment">// TODO 如果沿node右子树走到target的距离是K，把node添加进res</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rightDis &lt; K) </span><br><span class="line">                <span class="comment">// TODO 如果沿node右子树走到target的距离小于</span></span><br><span class="line">                <span class="comment">// 说明到target距离为K的节点在node的左子树上</span></span><br><span class="line">                <span class="comment">// 把node的左子树中到node的距离加上rightDis等于K的节点添加进res</span></span><br><span class="line">            <span class="comment">// 如果rightDis大于K，什么也不做</span></span><br><span class="line">            <span class="keyword">return</span> rightDis + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Helper(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><p>把上述思路翻译成代码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList&lt;<span class="built_in">int</span>&gt; <span class="title">DistanceK</span>(<span class="params">TreeNode root, TreeNode target, <span class="built_in">int</span> K</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="comment">// 添加了一个辅助函数，能把所有距离为K的节点添加到res中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddSubtree</span>(<span class="params">TreeNode node, <span class="built_in">int</span> dis</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis == K) &#123;</span><br><span class="line">            res.Add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们在上层函数保证了dis是小于K的，所以当dis不等于K时，可以继续向左右孩子搜索</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            AddSubtree(node.left, dis + <span class="number">1</span>);</span><br><span class="line">            AddSubtree(node.right, dis + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">Helper</span>(<span class="params">TreeNode node</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node == target) &#123;</span><br><span class="line">            AddSubtree(node, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">int</span> leftDis = Helper(node.left), rightDis = Helper(node.right);</span><br><span class="line">        <span class="keyword">if</span> (leftDis != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftDis == K) &#123;</span><br><span class="line">                res.Add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (leftDis &lt; K) &#123;</span><br><span class="line">                AddSubtree(node.right, leftDis + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> leftDis + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightDis != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightDis == K) &#123;</span><br><span class="line">                res.Add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rightDis &lt; K) &#123;</span><br><span class="line">                AddSubtree(node.left, rightDis + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rightDis + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Helper(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>标题猛一看，挺唬人的。但第二个递归只是第一个递归的辅助，没有第二个递归也不妨碍我们从整体上理解解题思路。解决递归类问题，可以自顶向下分析，确定好递归函数的功能，大体上试一下可行，然后确定好递归的结束条件和主体处理操作，就完事了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/25/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%91/" class="post-title-link" itemprop="url">LeetCode分享（序列化和反序列化树）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-25 20:15:50" itemprop="dateCreated datePublished" datetime="2021-03-25T20:15:50+08:00">2021-03-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-11 13:09:11" itemprop="dateModified" datetime="2021-05-11T13:09:11+08:00">2021-05-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近在二刷LeetCode的高频题，好几次看到了“序列化和反序列化”的字样。便准备把几道相关的题目整理在一起，加强印象。相关题目有三道，按题号顺序分别是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">LeetCode 297. 二叉树的序列化与反序列化</a>；</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-n-ary-tree/">LeetCode 428. 序列化和反序列化 N 叉树</a>；</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">LeetCode 449. 序列化和反序列化二叉搜索树</a>。</li>
</ul>
<p>三道题分别是Hard，Hard，Medium，但不要被Hard吓到，再怎么序列化，也逃不过深度优先搜索、广度优先搜索的架子。</p>
<h2 id="0-序列化"><a href="#0-序列化" class="headerlink" title="0. 序列化"></a>0. 序列化</h2><p>二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。</p>
<p>广度优先搜索的二叉树序列化很容易，用二叉树的层次遍历就可以。深度优先搜索的实现方式更多，前序、中序、后序遍历都可以，只是对根节点处理的位置不同而已。唯独需要注意的是，无法根据中序遍历的结果反序列化为原始的树结构，因为根据序列化结果找不到根节点位置。但前序和后序是可以的，前序序列化后根节点在就在第一个位置，后序的在最后一个位置，然后从构建根开始，我们也能继续从结果中找到根的左右子树的根节点，所以反序列化可以一直进行下去。 </p>
<p>如果只靠单个序列化结果反序列化重构对应的树，还需要特别注意一点，要在序列化结果中加上表示叶子节点左右“空孩子”的占位符，以让算法知道什么时候构建到叶子节点，进而结束该位置的构建。</p>
<h2 id="1-广度优先序列化"><a href="#1-广度优先序列化" class="headerlink" title="1. 广度优先序列化"></a>1. 广度优先序列化</h2><p>广度优先要借助队列实现，因为要先入先出，举个例子，从一棵二叉树的根开始搜索，在根节点出队的时候把根的孩子节点依次入队。在队列中，每个孩子节点都是和它的兄弟节点挨着，这样，当要开始控制孩子节点出队的时候，就可以再把孩子节点的孩子节点们入队了。在把同属一层的节点出队的同时把他们的孩子依次入队，如此迭代，这就是二叉树的层次遍历。我们使用二叉树层次遍历的方案获得序列化结果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">serialize</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    queue.Enqueue(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.Count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次出队一个节点</span></span><br><span class="line">        <span class="keyword">var</span> node = queue.Dequeue();</span><br><span class="line">        <span class="comment">// 如果是叶子节点的空孩子节点</span></span><br><span class="line">        <span class="comment">// 用“null”占位</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            res.Add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，记录节点的值，并把左右孩子入队</span></span><br><span class="line">        <span class="comment">// 在真正的二叉树层次遍历里，是不需要把空节点入队的，但这里我们需要空节点的占位信息，所以把空节点也入队了</span></span><br><span class="line">        res.Add(node.val.ToString());</span><br><span class="line">        queue.Enqueue(node.left);</span><br><span class="line">        queue.Enqueue(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个简单的例子来看一下二叉树层次遍历序列化结果。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
</blockquote>
<p>按照层级遍历序列化算法：</p>
<ul>
<li>先把3入队；</li>
<li>判断队列不为空，把3出队，判断不是null，记录节点的值，现在res=[3]，然后把左右孩子9、20入队；<ul>
<li>判断队列不为空，把9出队，判断不是null，记录节点的值，现在res=[3,9]，然后把左右孩子null、null入队；</li>
<li>判断队列不为空，把20出队，判断不是null，记录节点的值，现在res=[3,9,20]，然后把左右孩子15、7入队；<ul>
<li>判断队列不为空，把null出队，判断是null，记录为“null”，现在res=[3,9,20,null]，继续下次循环；</li>
<li>判断队列不为空，把null出队，判断是null，记录为“null”，现在res=[3,9,20,null,null]，继续下次循环；</li>
<li>判断队列不为空，把15出队，判断不是null，记录节点的值，现在res=[3,9,20,null,null,15]，然后把左右孩子null、null入队；</li>
<li>判断队列不为空，把7出队，判断不是null，记录节点的值，现在res=[3,9,20,null,null,15,7]，然后把左右孩子null、null入队；<ul>
<li>判断队列不为空，把null出队，判断是null，记录为“null”，现在res=[3,9,20,null,null,15,7,null]，继续下次循环；</li>
<li>判断队列不为空，把null出队，判断是null，记录为“null”，现在res=[3,9,20,null,null,15,7,null,null]，继续下次循环；</li>
<li>判断队列不为空，把null出队，判断是null，记录为“null”，现在res=[3,9,20,null,null,15,7,null.null,null]，继续下次循环；</li>
<li>判断队列不为空，把null出队，判断是null，记录为“null”，现在res=[3,9,20,null,null,15,7,null,null,null,null]，继续下次循环；</li>
<li>判断队列为空，序列化结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>不同的缩进代表不同层级节点的迭代过程。最终的序列化结果为“3,9,20,null,null,15,7,null,null,null,null”。</p>
<h2 id="2-广度优先反序列化"><a href="#2-广度优先反序列化" class="headerlink" title="2. 广度优先反序列化"></a>2. 广度优先反序列化</h2><p>从广度优先序列化结果我们就可以看出，根节点3的左右孩子9，20就跟在它的后面；然后再往后看，接下来两个是null、null，这两个是谁的孩子呢？肯定是9的。因为我们在序列化的时候，也是先把9的孩子入队，然后才把20的孩子入队，按照出队的顺序，也是null、null在15、7的前面。能理解这点，我们很自然地就能写出反序列化的代码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span>(<span class="params"><span class="built_in">string</span> data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 先把逗号分隔的序列化结果转成数组形式</span></span><br><span class="line">    <span class="built_in">string</span>[] nodes = data.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;TreeNode&gt;();</span><br><span class="line">    <span class="comment">// 构建根节点</span></span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">new</span> TreeNode(<span class="built_in">int</span>.Parse(nodes[<span class="number">0</span>]));</span><br><span class="line">    queue.Enqueue(root);</span><br><span class="line">    <span class="comment">// 节点访问指示器</span></span><br><span class="line">    <span class="built_in">int</span> idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.Count != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 每次出队一个节点</span></span><br><span class="line">        <span class="keyword">var</span> node = queue.Dequeue();</span><br><span class="line">        <span class="comment">// 构建节点的左孩子</span></span><br><span class="line">        node.left = nodes[idx] == <span class="string">&quot;null&quot;</span> ? <span class="literal">null</span> : <span class="keyword">new</span> TreeNode(<span class="built_in">int</span>.Parse(nodes[idx]));</span><br><span class="line">        <span class="comment">// 如果左孩子为null，则该节点的左子树就构建完成了，否则要先暂存左孩子，当指示器访问到左孩子的下一层元素时恢复构建</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.Enqueue(node.left);</span><br><span class="line">        <span class="comment">// 指示器向后移动</span></span><br><span class="line">        ++idx;</span><br><span class="line">        node.right = nodes[idx] == <span class="string">&quot;null&quot;</span> ? <span class="literal">null</span> : <span class="keyword">new</span> TreeNode(<span class="built_in">int</span>.Parse(nodes[idx]));</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.Enqueue(node.right);</span><br><span class="line">        ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照层级遍历反序列化算法：</p>
<p>输入序列化结果：“3,9,20,null,null,15,7,null,null,null,null”</p>
<ul>
<li>先构建第一个节点3并入队；</li>
<li>判断队列不为空，把3出队，判断指示器当前位置是9，构建为3的左孩子并入队，指示器向后移动，判断指示器当前位置是20，构建为3的右孩子并入队，指示器向后移动，；<ul>
<li>判断队列不为空，把9出队，判断指示器当前位置是“null”，构建为9的左孩子但不用入队，指示器向后移动，判断指示器当前位置是“null”，构建为9的右孩子但不用入队，指示器向后移动；</li>
<li>判断队列不为空，把20出队，判断指示器当前位置是15，构建为20的左孩子并入队，指示器向后移动，判断指示器当前位置是7 ，构建为9的右孩子并入队，指示器向后移动；<ul>
<li>判断队列不为空，把15出队，判断指示器当前位置是“null”，构建为15的左孩子但不用入队，指示器向后移动，判断指示器当前位置是“null”，构建为15的右孩子但不用入队，指示器向后移动；</li>
<li>判断队列不为空，把7出队，判断指示器当前位置是“null”，构建为7的左孩子但不用入队，指示器向后移动，判断指示器当前位置是“null”，构建为7的右孩子但不用入队，指示器向后移动；</li>
<li>判断队列为空，反序列化结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-深度优先序列化"><a href="#3-深度优先序列化" class="headerlink" title="3. 深度优先序列化"></a>3. 深度优先序列化</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">serialize</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Helper</span>(<span class="params">TreeNode node</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是叶子节点的空孩子节点</span></span><br><span class="line">        <span class="comment">// 用“null”占位并结束递归</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            res.Add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，记录节点的值，并递归遍历左右子树</span></span><br><span class="line">            res.Add(node.val.ToString());</span><br><span class="line">            Helper(node.left);</span><br><span class="line">            Helper(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Helper(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还用上面的例子来看一下二叉树层次遍历序列化结果。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line">/ \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line">15   7</span><br></pre></td></tr></table></figure>
</blockquote>
<p>按照深度优先遍历序列化算法：</p>
<ul>
<li>当前根节点为3，记录节点的值，现在res=[3]；<ul>
<li>递归进入节点3的左子树，当前根节点为9，记录节点的值，现在res=[3,9]；<ul>
<li>递归进入节点9的左子树，当前根节点为null，记录节点的值，现在res=[3,9,null]，结束递归；</li>
<li>递归进入节点9的右子树，当前根节点为null，记录节点的值，现在res=[3,9,null,null]，结束递归；</li>
</ul>
</li>
<li>递归进入节点3的右子树，当前根节点为20，记录节点的值，现在res=[3,9,null,null,20]；<ul>
<li>递归进入节点20的左子树，当前根节点为15，记录节点的值，现在res=[3,9,null,null,20,15]；<ul>
<li>递归进入节点15的左子树，当前根节点为null，记录节点的值，现在res=[3,9,null,null,20,15,null]，结束递归；</li>
<li>递归进入节点15的右子树，当前根节点为null，记录节点的值，现在res=[3,9,null,null,20,15,null,null]，结束递归；</li>
</ul>
</li>
<li>递归进入节点20的右子树，当前根节点为7，记录节点的值，现在res=[3,9,null,null,20,15,null,null,7]；<ul>
<li>递归进入节点7的左子树，当前根节点为null，记录节点的值，现在res=[3,9,null,null,20,15,null,null,7,null]，结束递归；</li>
<li>递归进入节点7的右子树，当前根节点为null，记录节点的值，现在res=[3,9,null,null,20,15,null,null,7,null,null]，结束递归；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>序列化结束。</li>
</ul>
<p>不同的缩进代表不同的递归层级。最终的序列化结果为“3,9,null,null,20,15,null,null,7,null,null”。</p>
<h2 id="4-深度优先反序列化"><a href="#4-深度优先反序列化" class="headerlink" title="4. 深度优先反序列化"></a>4. 深度优先反序列化</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span>(<span class="params"><span class="built_in">string</span> data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 先把逗号分隔的序列化结果转成数组形式</span></span><br><span class="line">    <span class="built_in">string</span>[] nodes = data.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="comment">// 节点访问指示器</span></span><br><span class="line">    <span class="built_in">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Helper</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果访问到“null”，说明是空孩子节点，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (nodes[idx] == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建当前根节点</span></span><br><span class="line">        <span class="keyword">var</span> root = <span class="keyword">new</span> TreeNode(<span class="built_in">int</span>.Parse(nodes[idx]));</span><br><span class="line">        <span class="comment">// 指示器向后移动，并开始递归构建左子树</span></span><br><span class="line">        ++idx;</span><br><span class="line">        root.left = Helper();</span><br><span class="line">        <span class="comment">// 构建完左子树后，指示器向后移动，并开始递归构建右子树</span></span><br><span class="line">        ++idx;</span><br><span class="line">        root.right = Helper();</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Helper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照深度优先遍历反序列化算法：</p>
<p>输入序列化结果：“3,9,null,null,20,15,null,null,7,null,null”</p>
<ul>
<li><p>判断指示器当前位置是3，构建当前根节点3；</p>
<ul>
<li>指示器向后移动，递归构建节点3的左子树，判断指示器当前位置是9，构建当前根节点9；<ul>
<li>指示器向后移动，递归构建节点9的左子树，判断指示器当前位置是“null”，返回null，递归结束；</li>
<li>指示器向后移动，递归构建节点9的右子树，判断指示器当前位置是“null”，返回null，递归结束；</li>
</ul>
</li>
<li>指示器向后移动，递归构建节点3的右子树，判断指示器当前位置是20，构建当前根节点20；<ul>
<li>指示器向后移动，递归构建节点20的左子树，判断指示器当前位置是15，构建当前根节点15；<ul>
<li>指示器向后移动，递归构建节点15的左子树，判断指示器当前位置是“null”，返回null，递归结束；</li>
<li>指示器向后移动，递归构建节点15的右子树，判断指示器当前位置是“null”，返回null，递归结束；</li>
</ul>
</li>
<li>指示器向后移动，递归构建节点20的右子树，判断指示器当前位置是7，构建当前根节点7；<ul>
<li>指示器向后移动，递归构建节点7的左子树，判断指示器当前位置是“null”，返回null，递归结束；</li>
<li>指示器向后移动，递归构建节点7的右子树，判断指示器当前位置是“null”，返回null，递归结束；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>反序列化结束。</p>
</li>
</ul>
<h2 id="5-N叉树的序列化和反序列化"><a href="#5-N叉树的序列化和反序列化" class="headerlink" title="5.N叉树的序列化和反序列化"></a>5.N叉树的序列化和反序列化</h2><p>N叉树和二叉树有什么区别？无非就是根的孩子节点个数不确定，而二叉树的孩子节点个数是确定的两个。所以我们才可以在广度优先和深度优先反序列化算法中，直接从序列化结果中按一定顺序获取根节点后面的两个元素来构建根节点的左右孩子。所以把二叉树的序列化和反序列化算法应用到N叉树上的时候，只需要在序列化结果中额外添加代表当前根节点孩子节点个数的控制信息即可。</p>
<p>N叉树的深度优先序列化和反序列化算法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">serialize</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Helper</span>(<span class="params">TreeNode node</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            res.Add(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.Add(node.val.ToString());</span><br><span class="line">        <span class="comment">// 关键，把N叉树节点的孩子个数添加到序列化结果中</span></span><br><span class="line">        res.Add(node.children.Count.ToString());</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> node.children) &#123;</span><br><span class="line">            Helper(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Helper(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span>(<span class="params"><span class="built_in">string</span> data</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">string</span>[] nodes = data.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="built_in">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Helper</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[idx] == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> root = <span class="keyword">new</span> TreeNode(<span class="built_in">int</span>.Parse(nodes[idx]), <span class="keyword">new</span> List&lt;TreeNode&gt;());</span><br><span class="line">        <span class="keyword">var</span> num = <span class="built_in">int</span>.Parse(nodes[++idx]);</span><br><span class="line">        <span class="comment">// 关键，根据获取的N叉树节点的孩子个数控制递归走向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">            ++idx;</span><br><span class="line">            root.children.Add(Helper());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Helper();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者们可以尝试自己改写出N叉树的层次遍历序列化和反序列化算法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/03/20/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/20/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">堆和堆排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-20 20:22:16" itemprop="dateCreated datePublished" datetime="2021-03-20T20:22:16+08:00">2021-03-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-11 13:09:11" itemprop="dateModified" datetime="2021-05-11T13:09:11+08:00">2021-05-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>相信很多读者在学习排序算法的时候，理解并背下了快速排序和归并排序的代码。而对于堆排序可能了解不多，对堆的印象可能只停留在大顶堆堆顶元素最大，小顶堆堆顶元素最小。但其实，堆排序才是个人认为的原理最简单、代码最简洁的一种优秀排序算法。</p>
<h2 id="0-完全二叉堆"><a href="#0-完全二叉堆" class="headerlink" title="0. 完全二叉堆"></a>0. 完全二叉堆</h2><p>在深入了解堆之前，可以先想这么一个问题，堆长什么样？有的读者会觉得，（大顶）堆堆顶元素最大，然后它的左右孩子比它小，所以应该是树怎么存，它就怎么存吧。用一个个的节点存值，然后节点的左右孩子指针指向它的左右孩子。这确实没错，但要注意到完全二叉堆在逻辑结构上等同于一棵完全二叉树，跟线性的数组有着紧密的对应关系。所以我们可以用数组来存储这个完全二叉堆，这么做的优势也很明显，各节点在物理上连续排列，还可以轻松的按照索引来访问节点。</p>
<h2 id="1-完全二叉堆的表示"><a href="#1-完全二叉堆的表示" class="headerlink" title="1. 完全二叉堆的表示"></a>1. 完全二叉堆的表示</h2><p>铺垫了这么多，我们来看一个堆的实例，理解完全二叉堆的表示和存储。</p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210320134454.png" alt="image-20210320134454529"></p>
<p>如图，右边是我们想象中的一个小顶堆的样子，左上角的完全二叉树是这个小顶堆对应的二叉树表示，左下角连续排列的元素是该完全二叉树按层次遍历得到的结果，元素的不同层级代表了元素在完全二叉树中所处的不同深度。这一实现方式的优势首先体现在，各节点在物理上连续排列，故总共仅需$O(n)$空间。而更重要地是，利用各节点在数组中的索引，也可便捷地判别父子关系。比如，节点<strong>2</strong>在数组中的索引是2，而它的左右孩子<strong>5</strong>和<strong>6</strong>的索引分别是5和6，恰好满足$5=2 \times 2+1,6=2 \times 2+2$。更一般的，对于索引为$i$的节点，它的左右孩子和父节点的索引必然满足：<br>$$<br>左孩子索引=2 \times i + 1, 右孩子索引=2 \times i + 2, 父节点索引=\lceil i / 2 \rceil + 1<br>$$</p>
<h2 id="2-完全二叉堆的操作"><a href="#2-完全二叉堆的操作" class="headerlink" title="2. 完全二叉堆的操作"></a>2. 完全二叉堆的操作</h2><p>当在完全二叉堆中插入或者删除元素后，完全二叉堆的“堆序性”可能不在满足，所谓的“堆序性”是指堆顶以外的每个节点都不小（大）于其父节点。而为了让完全二叉堆重新满足“堆序性”，需要对其进行上滤和下滤操作。</p>
<h3 id="2-1-上滤"><a href="#2-1-上滤" class="headerlink" title="2.1 上滤"></a>2.1 上滤</h3><p>上滤发生在向堆中插入新元素的时候，首先要把待插入元素置于数组末尾，然后不断调整其和父节点的偏序关系，这一过程体现在树中就仿佛叶子节点在不断向上浮，因此叫上滤。</p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210320143050.png" alt="image-20210320143050475"></p>
<p>在如图(a)所示由5个元素组成的初始堆中，现拟插入值为5的新元素。为此：</p>
<ul>
<li>首先如图(b)所示，将该元素置于数组的末尾；</li>
<li>新元素5与其父节点0逆序，故如图(c)所示，经一次交换之后，新元素5上升一层；</li>
<li>新元素5与其新的父节点4依然逆序，故如图(d)所示，经一次交换后再上升一层；</li>
<li>此时因5已抵达堆顶，插入操作完毕，故算法终止。</li>
</ul>
<h3 id="2-2-下滤"><a href="#2-2-下滤" class="headerlink" title="2.2 下滤"></a>2.2 下滤</h3><p>下滤发生在从堆中删除最值元素的时候，首先从数组头部将最值元素摘除，接着为调整偏序关系，需要把数组末尾元素交换到头部，然后不断调整头部元素和其孩子节点的偏序关系，这一过程体现在树中就仿佛根节点在不断向下沉，因此叫下滤。</p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210320144445.png" alt="image-20210320144445675"></p>
<p>从如图(a)所示由6个元素组成的完全堆中，现拟删除堆顶元素5。为此：</p>
<ul>
<li>首先如图(b)所示 将该元素摘除，并将向量的末元素1转入首单元，当作堆顶；</li>
<li>1与其孩子节点均逆序。故如图(c)所示，在与其孩子中的大者4交换之后，1下降一层；</li>
<li>1与其新的孩子2依然逆序，故如图(d)所示经又一次交换后再下降一层；</li>
<li>此时因1已抵达底层，删除操作完毕，算法成功终止。</li>
</ul>
<h3 id="2-3-建堆"><a href="#2-3-建堆" class="headerlink" title="2.3 建堆"></a>2.3 建堆</h3><p>建堆的方式有好多种，我们只讲复杂度最低的一种：<strong>Floyd建堆</strong>。</p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210320145230.png" alt="image-20210320145230665"></p>
<p>首先如图(a)所示，将9个元素组织为一棵完全二叉树。 要注意到，在多数情况下，输入数据都是以数组形式给出，故除了明确各元素间的父子关系外，并不需要做任何实质的操作。此时，所有叶节点各自即是一个规模为1的堆。之后，自底而上地逐层合并：</p>
<ul>
<li>首先如图(b)所示，在对3实施下滤调整之后，{ 8 }和{ 5 }合并为{ 8, 3, 5 }；</li>
<li>接下来如图(c)所示，在对1实施下滤调整之后，{ 8, 3, 5 }与{ 9 }合并为{ 9, 8, 1, 3, 5 }； </li>
<li>对6实施下滤调整之后，{ 7 }与{ 4 }合并为{ 7, 6, 4 }；</li>
<li>最后如图(d)所示，在对2实施下滤调整之后，{ 9, 8, 1, 3, 5 }与{ 7, 6, 4 }合并为{ 9, 8, 7, 5, 1, 6, 4, 3, 2 }，建堆完毕。</li>
</ul>
<h3 id="2-4-操作复杂度"><a href="#2-4-操作复杂度" class="headerlink" title="2.4 操作复杂度"></a>2.4 操作复杂度</h3><p>上滤和下滤：最多进行树高次，而每次调整的仅涉及两个元素的交换，时间复杂度为$O(1)$，因此，上滤和下滤的时间复杂度为$O(\log_2n )$。</p>
<p>Floyd建堆：时间复杂为$O(n)$，建堆算法需做n步迭代，以对所有节点各做一次下滤。这里，每个节点的下滤所需的时间线性正比于其高度，故总体运行时间取决于各节点的高度总和。</p>
<h2 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3. 堆排序"></a>3. 堆排序</h2><p>有了上滤、下滤、建堆的基础，我们就可以实现堆排序了，这里介绍原地堆排序算法。</p>
<p><img src="https://gitee.com/molinchn/BlogImage/raw/master/duanyang/20210320151222.png" alt="image-20210320151222832"></p>
<p>图中Heap为大顶堆部分，Sorted为有序区部分。Heap和Sorted都在一个数组中存储，只是通过不同的索引来控制两部分的范围。最开始Heap占据整个数组，Sorted为空，随着我们不断将Heap中堆顶的最大元素交换到Sorted部分，Heap规模逐渐减小，Sorted规模逐渐扩大，又因为每次从Heap交换到Sorted中的最大值都在上一个最大值的左边，所以Sorted保持升序。</p>
<p>更具体的，首先如图(a)，取出首元素M，将其与末元素X交换，如此交换之后M必处于正确的排序位置。故如图(b)，此时可等效地认为Sorted向前扩大了一个单元，Heap相应地缩小了一个单元。 但存在的问题是，元素X在Heap中的位置不一定准确，但只需对X实施一次下滤调整，即可使Heap整体的堆序性重新恢复，结果如图(c)所示。重复上述操作，当Sorted规模扩大到整个数组，即完成了原地堆排序。</p>
<h2 id="4-堆、完全二叉树、完全二叉堆、优先级队列的关系"><a href="#4-堆、完全二叉树、完全二叉堆、优先级队列的关系" class="headerlink" title="4. 堆、完全二叉树、完全二叉堆、优先级队列的关系"></a>4. 堆、完全二叉树、完全二叉堆、优先级队列的关系</h2><p>在练习算法题时用过堆排序的读者可能会留意，在C++和Java语言中，“堆”是用优先级队列实现的。那堆、完全二叉堆、完全二叉树和优先级队列之间究竟是什么关系？</p>
<p><strong>堆（Heap）</strong>是计算机科学中的一种特别的<strong>完全二叉树</strong>。若是满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的母节点，那么P的值会小于等于（或大于等于）C的值”。</p>
<p><strong>堆</strong>的实现通常是通过构造<strong>完全二叉堆（Complete Binary Heap）</strong>，因为完全二叉堆应用很普遍，当不加限定时，堆通常指的就是完全二叉堆。</p>
<p>简单来说，堆其实就是指完全二叉堆。因为他们的堆序性和完全二叉性一样。</p>
<p>但其实，当我们提到堆时，往往关心的不是堆这种数据结构，而是它里面的偏序思想，也就是只从中获取最大值（最小值）、高优先级（低优先级）元素，并不关心其他元素。事实上，在C++的STL里，堆并不是一种容器，而是一种算法，只提供了关于堆调整的算法。</p>
<p>刚说了，能从堆里获取优先级最高（最低）的元素，所以把这种算法加上能够提供随机访问迭代器的容器（如：Vector），就得到了<strong>优先级队列</strong>。</p>
<p>所以，我们才能在代码中使用优先级队列来模拟“堆”。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>以上就是关于堆和堆排序的讲解，更具体的算法实现代码在后续文章中分享。文中所有图片和部分文字来源于清华大学出版的《数据结构（C++语言版）》，教材链接在文章最后。</p>
<p><a target="_blank" rel="noopener" href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/">https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/03/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E7%BB%9F%E4%B8%80%E5%86%99%E6%B3%95/" class="post-title-link" itemprop="url">二叉树遍历的统一化写法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-13 16:23:16" itemprop="dateCreated datePublished" datetime="2021-03-13T16:23:16+08:00">2021-03-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-11 13:09:11" itemprop="dateModified" datetime="2021-05-11T13:09:11+08:00">2021-05-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>二叉树遍历的递归版代码写法很简单，只用简单地调整访问节点操作和递归遍历左右子树的顺序即可写出三种遍历算法的代码。但在面试中，面试官想看的往往是迭代版的代码。然而二叉树的迭代遍历写法真的是五花八门，但原理却又都一样，都是借助栈的后进先出特性来保存遍历过程中的节点信息。下面为大家献上二叉树前、中、后序遍历的统一化迭代写法。</p>
<h2 id="0-前序遍历"><a href="#0-前序遍历" class="headerlink" title="0.前序遍历"></a>0.前序遍历</h2><p>算法思路来源于《数据结构（C++语言版）》P127 代码5.14。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; <span class="title">PreorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.Add(root.val);</span><br><span class="line">            stack.Push(root.right);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.Count == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        root = stack.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先一直沿着树向左搜索，每访问到一个节点，就把该节点添加到的访问列表中，同时记录该节点的右孩子信息。这样当搜索到最左下叶子节点后，即可从栈中弹出该叶子节点父节点的右孩子，进而实现“根-左-右”的前序遍历。</p>
<h2 id="1-中序遍历"><a href="#1-中序遍历" class="headerlink" title="1.中序遍历"></a>1.中序遍历</h2><p>算法思路来源于《数据结构（C++语言版）》P129 代码5.15。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; <span class="title">InorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.Push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.Count == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        root = stack.Pop();</span><br><span class="line">        res.Add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先一直沿着树向左搜索，每访问到一个节点，就记录该节点的信息。这样当搜索到最左下叶子节点，即可从栈中弹出该叶子节点并添加到访问列表中，再弹出该节点的父节点并添加到访问列表中，然后转而搜索该父节点的右孩子，进而实现“根-左-右”的前序遍历。</p>
<h2 id="2-后序遍历"><a href="#2-后序遍历" class="headerlink" title="2.后序遍历"></a>2.后序遍历</h2><p>算法思路来源于<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode145. 二叉树的后序遍历</a>的题解，主要思想是先实现一个“根-右-左”顺序的前序遍历，然后再将结果翻转即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; <span class="title">PostorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.Add(root.val);</span><br><span class="line">            stack.Push(root.left);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.Count == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        root = stack.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">    res.Reverse();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前序遍历一样，只不过我们按照“根-右-左”的顺序来控制入栈和搜索。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>在刷题的过程中，看到过各种各样的二叉树遍历写法，要么分支控制太多、栈操作太多，要么三种写法不够统一，记忆起来比较苦恼。直到最近在看数据结构的书，被书上的二叉树迭代版遍历算法的简练所折服。又联系到之前掌握的前序、后序的统一化写法，便有了现在的非常简洁的二叉树前、中、后序遍历的统一化写法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://mrliduanyang.github.io/2021/03/13/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrliduanyang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="N.O的个人技术备忘">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/13/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">LeetCode分享（单调队列+滑动窗口）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-13 16:23:16" itemprop="dateCreated datePublished" datetime="2021-03-13T16:23:16+08:00">2021-03-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-11 13:09:11" itemprop="dateModified" datetime="2021-05-11T13:09:11+08:00">2021-05-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="0-单调队列"><a href="#0-单调队列" class="headerlink" title="0.单调队列"></a>0.单调队列</h2><p>在使用单调队列之前，可以根据之前分享的单调栈文章来理解单调队列的原理和特性。单调队列相对于单调栈的区别是，单调栈只能从栈顶出栈，而单调队列可以从队首和队尾出队。既然可以在队首和队尾操作元素，那么我们可以想象一下如下的操作：</p>
<ul>
<li>队尾入队，队首出队：很像滑动窗口的操作。</li>
<li>队尾出队，队尾入队：单调队列的操作。</li>
</ul>
<p>所以我们可以发现，单调队列可以和滑动窗口结合起来，用来解决滑动窗口内元素最值的问题。</p>
<h2 id="1-单调队列实战"><a href="#1-单调队列实战" class="headerlink" title="1.单调队列实战"></a>1.单调队列实战</h2><h3 id="1-1-LeetCode-239-滑动窗口最大值"><a href="#1-1-LeetCode-239-滑动窗口最大值" class="headerlink" title="1.1  LeetCode 239. 滑动窗口最大值"></a>1.1  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">LeetCode 239. 滑动窗口最大值</a></h3><blockquote>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑 动窗口中的最大值。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [1,3,-1,-3,5,3,6,7], k = 3<br><strong>输出：</strong>[3,3,5,5,6,7]<br><strong>解释：</strong><br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [1], k = 1<br><strong>输出：</strong>[1]</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>nums = [1,-1], k = 1<br><strong>输出：</strong>[1,-1]</p>
</blockquote>
<p>套用第0节中滑动窗口和单调队列的操作，我们可以使用一个双端队列，用队尾入队、队首出队来存储滑动窗口内的元素，并用队尾出队、队尾入队来维持队列中元素的单调性以记录最值。所以我们可以写出解决该问题的代码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">MaxSlidingWindow</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> k</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> n = nums.Length;</span><br><span class="line">    <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 使用链表模拟双端队列</span></span><br><span class="line">    LinkedList&lt;<span class="built_in">int</span>&gt; deque = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 实现单调递减队列</span></span><br><span class="line">        <span class="keyword">while</span> (deque.Count != <span class="number">0</span> &amp;&amp; nums[deque.Last()] &lt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 如果队列不为空，并且待入队元素值大于队尾元素值，队尾元素出队，维持队列的单调递减性</span></span><br><span class="line">            deque.RemoveLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队列单调性满足后，新元素队尾入队</span></span><br><span class="line">        deque.AddLast(i);</span><br><span class="line">        <span class="comment">// 实现滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span> (deque.First() &lt; (i - k + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 添加了下标为i的元素后，如果队列中元素的下标范围超过窗口范围k，队首元素出队</span></span><br><span class="line">            deque.RemoveFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录最终结果</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            res[i - k + <span class="number">1</span>] = nums[deque.First()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-LeetCode-1438-绝对差不超过限制的最长连续子数组"><a href="#1-2-LeetCode-1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1.2 LeetCode 1438. 绝对差不超过限制的最长连续子数组"></a>1.2 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">LeetCode 1438. 绝对差不超过限制的最长连续子数组</a></h3><blockquote>
<p>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p>
<p>如果不存在满足条件的子数组，则返回 0 。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums = [8,2,4,7], limit = 4<br><strong>输出：</strong>2<br><strong>解释：</strong>所有子数组如下：<br>[8] 最大绝对差 |8-8| = 0 &lt;= 4.<br>[8,2] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.<br>[2] 最大绝对差 |2-2| = 0 &lt;= 4.<br>[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.<br>[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.<br>[4] 最大绝对差 |4-4| = 0 &lt;= 4.<br>[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.<br>[7] 最大绝对差 |7-7| = 0 &lt;= 4.<br>因此，满足题意的最长子数组的长度为 2 。</p>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums = [10,1,2,4,7,2], limit = 5<br><strong>输出：</strong>4<br><strong>解释：</strong>满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</p>
<p><strong>示例 3：</strong></p>
<p><strong>输入：</strong>nums = [4,2,2,2,4,4,2,2], limit = 0<br><strong>输出：</strong>3</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">LongestSubarray</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> limit</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, n = nums.Length;</span><br><span class="line">    <span class="comment">// 使用链表模拟双端队列</span></span><br><span class="line">    <span class="keyword">var</span> max = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> min = <span class="keyword">new</span> LinkedList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 实现单调递减队列</span></span><br><span class="line">        <span class="keyword">while</span> (max.Count &gt; <span class="number">0</span> &amp;&amp; nums[max.Last()] &lt;= nums[right]) max.RemoveLast();</span><br><span class="line">        <span class="comment">// 实现单调递增队列</span></span><br><span class="line">        <span class="keyword">while</span> (min.Count &gt; <span class="number">0</span> &amp;&amp; nums[min.Last()] &gt;= nums[right]) min.RemoveLast();</span><br><span class="line">        <span class="comment">// 滑动窗口扩张</span></span><br><span class="line">        max.AddLast(right);</span><br><span class="line">        min.AddLast(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 维护队列元素下标范围（只需要[left, right]内的元素）</span></span><br><span class="line">        <span class="keyword">if</span> (max.First() &lt; left) max.RemoveFirst();</span><br><span class="line">        <span class="keyword">if</span> (min.First() &lt; left) min.RemoveFirst();</span><br><span class="line">        <span class="comment">// 滑动窗口收缩</span></span><br><span class="line">        <span class="keyword">if</span> (nums[max.First()] - nums[min.First()] &gt; limit) left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该题相对于上一题而言，思想没变，仅仅是增加了一个记录区间最小值的单调递增队列。</p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h2><p>在上面两道题目的算法实现细节中，有一点需要注意：</p>
<blockquote>
<p>为什么找最大值要用单调递减队列，而不用单调递增队列，单调递增队列，大的值在队尾，不是也能找到最大值吗？</p>
</blockquote>
<p>用语言来概括就是，单调递减队列中可以保留某个“最大值”之后其他的“最大值”信息。具体的，在单调递减队列中，最大值在队首，最小值在队尾，这样在队尾操作元素维护单调性的时候，不至于把最大值弄丢，可以尽量的保留最大值。举个例子，令239题中的<strong>nums=[1,2,3,4,1,2,3,4]，k=3</strong>，使用单调递增队列来解决该题目。当滑动窗口滑动到子数组**[2,3,4]<strong>时，单调队列中存储</strong>[2,3,4]<strong>，当窗口继续右移</strong>1<strong>位时，子数组为</strong>[3,4,1]<strong>，单调队列中存储</strong>[1]<strong>，我们可以发现，原来队列中的较大值</strong>2,3,4<strong>都在</strong>1**入队的时候被挤掉了，这就导致了最大值结果不正确。</p>
<p>总而言之，我们在解决最大值问题上使用单调递减队列，将大的值存储在靠近队尾的位置，尽可能避免丢失最大值；在解决最小值问题上使用单调递增队列，将小的值存储在靠近队尾的位置，尽可能避免丢失最小值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>
<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">津ICP备20002882号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mrliduanyang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
