---
title: 动态规划问题的一般化分析方法
date: 2020-11-02 18:55:21
categories: 算法
---

## 0x00 前言

身为一个准程序员，不刷题是不可能的。我是看了labuladong东哥的系列文章才开始上LeetCode刷题。把东哥的文章的过了两遍以后，开始上手做树相关的题，树的做了一些后，又做了回溯法的，最近准备肯动态规划这个绕不过去的硬骨头。先做了一道[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/) ，虽然是一道中等难度，但这个的状态转移以及dp数组的定义一眼就看出来。即使是该题的升级版[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) 也不过是调整dp数组的base以及在状态转移过程中添加一些判断。但这种一眼看穿的方法到了[494. 目标和](https://leetcode-cn.com/problems/target-sum/) 就不太行了，状态转移方程看不出来了。但经过我的分析，该题还是被解决了。在该过程中总结了一点分析动态规划问题的一般化方法。

## 0x01一般化方法

拿到一道动态规划题目，可以先用自顶向下的方法分析。以题目中的测试样例为例，我们的目标是用5个1凑出3，我们假定在最后一个1前添加**+**号，那么子问题就变成用4个1凑出2；同理，如果假定在最后一个1前添加**-**号，那么子问题就变成用4个1凑出4。所以dp数组的定义是什么呢？那就是用i个1凑出j的解有多少个。有了dp数组的定义，我们就很容易得到正确的状态转移，如：**dp[5, 3] = dp[4, 2] + dp[4, 4]** 。



